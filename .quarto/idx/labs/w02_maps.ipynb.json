{"title":"Static Maps in Python","markdown":{"yaml":{"title":"Static Maps in Python","author":"Gabriele Filomena","date":"today","format":{"html":{"code-fold":false}}},"headingText":"Part I: Basic Maps","containsRefs":false,"markdown":"\n\nThe **Lecture slides** can be found [here](https://github.com/GDSL-UL/wma/blob/main/lectures/w02.pdf).\n\nThis **lab**'s notebook can be downloaded from [here](https://github.com/GDSL-UL/wma/blob/main/labs/w02_maps.ipynb).\n\n\nIn this session, we will use the libraries `matplotlib` and `contextily` to plot the information represented into different `GeoDataFrames`. \nWe will look into plotting `Point`, `LineString` and `Polygon` `GeoDataFrames`. Most of the plots here are rather ugly but, at this point, the goal is to get familiar with the parameters of the plot function and what can be done with them.\n\n### Plotting Points\n\nLoad the data of terrorist attacks 1970-2020 and choose a country. Germany is used as a case study here but feel free to change the country.\nIf you do so, also change the `crs` (see https://epsg.io).\n\nCreating the `GeoDataFrame` from the `DataFrame`\n\nBasic plotting\n\nSlightly improving the plot:\n\n#### Adding some context: Base Maps with `Contextily`\nsee providers and options here https://xyzservices.readthedocs.io/en/stable/introduction.html\n\n#### Parameters specific to `Point` in the `plot` method \n- `markersize`: numerical value (for now)\n- `marker`: see https://matplotlib.org/stable/api/markers_api.html\n\n##### Other properties, shape independent:\n- `color`: https://matplotlib.org/3.1.0/gallery/color/named_colors.html\n- `alpha`: regulates transparency of the shape: 0 to 1\n\n### Plotting LineStrings\nLet's import railway tracks in the Western Balkans (Slovenia, Croatia, Bosnia & Herzegovina, Montenegro, Serbia, Kosovo)\n\nOne can also filter prior to plotting, based on the columns in the GeoDataFrame. First we download Serbia's Boundary with `OSMNX`, more on that later on. Then we filter `lines_gdf` with a `within` operation.\n\n#### Parameters specific to `LineString`: \n- `linewidth`: numerical value (for now).\n- `capstyle`: controls how Matplotlib draws the corners where two different line segments meet. See https://matplotlib.org/stable/gallery/lines_bars_and_markers/capstyle.html\n- `joinstyle`': controls how Matplotlib draws the corners where two different line segments meet. https://matplotlib.org/stable/gallery/lines_bars_and_markers/joinstyle.html\n\n### Plotting Polygons\nWe are again using `OSMNX` to download data from `OpenStreetMap` automatically. In this case, we will get building footprints from the city of Algiers in Alageria.\n\n#### Parameter specific to `Polygon`: \n- `edgecolor`: the outline of the polygon, by default = `None` (often better).\n- `linewidth`: the width of the outline of the polygon.\n\nFor polygons, you can also plot just the boundaries of the geometries by:\n\n### Plotting more than one layer together\nLet's also download roads for Algiers\n\nAnd plot everything togehter. It's important to keep in mind that the last layer is always rendered on top of the others. In other words, they may cover the previous ones.\n\nHowever, you can prevent this by passing arguments to the parameter `zorder` in the `plot` method. The layer with the higher zorder value will be plotted on top. \n\n### Sub-plots\nTo obtain multiple sub-plots, we manipulate the `nrows`, `ncols` parameters. We can use this approach to:\n* Plot the same layer with different properties.\n\n* Plot different layers.\n\n* Analyse phenomena across different geographical areas. For example, terrorism in Germany and in the UK.\n\n<div class=\"alert alert-success\">\n\n**Exercise**:\n\n* Think about the plots above and how they could be improved. \n* Copy and paste the code and execute the functions playing with the different parameters.\n* Produce a neat map using the `GeoDataFrame`s available in this notebook or the ones employed in the previous sessions, making use of the elements/parameters discussed here.\n* Try out different tiles for the basemap to familiarise yourself with what's available.\n    \n</div>\n\n## Part II: Choropleth Mapping\n\n**Data**\n\nFor this second part of the tutorial, we will use some data at the municipality level for Serbia. The data contains information regarding poverty level, average income, population and tourism. The data is taken from https://data.stat.gov.rs/?caller=SDDB&languageCode=en-US and can be associated to the polygons representing the administrative boundaries of the municipalities. These boundaries can be found here https://data.humdata.org/dataset/geoboundaries-admin-boundaries-for-serbia?force_layout=desktop.\nWhile most of the data refers to 2023, the admin boundaries file traces back to 2017. Thus, it may contain obsolete information (few changes may occur).\n\nLater on, we will go back to the terrorism dataset.\n\nLet's plot the `GeoDataFrame` following the last session's steps.\n\nThe we load the data and merge it into the `GeoDataFrame`, before getting rid of municipalities that do not have a corresponding shape/record in the GeoDataFrame (probably the result of changes in the national subdivisions).\n\nCreating a choropleth map is rather straightforward and can ben done by using few other parameters. Reflect on what you see and whether the map below is informative.\n\n### Choropleth Maps for Numerical Variables\nWe are essentially  using the same approach employed for creating basic maps, the method `plot`, but we now need to pass arguments to some new parameters to specify which column is to be represented and how. As an optional argument, one can set legend to `True` and the resulting figure will include a colour bar.\n\n- `column`: the name of the column representing the variable that we want to use to colour-code our shapes.\n- `scheme`: the scheme used to colour the shapes based on the variable values.\n- `cmap`: the colormap used to show variation.\n\n#### Colormaps\n\nBuilt-in colour maps can be found here https://matplotlib.org/stable/gallery/color/colormap_reference.html.\nHowever one can create new ones as follows from a list of colours:\n\nor from colour names: \n\nLet's try a new colormap and let's also set a number of classes to divide the data in, through the parameter `k`.\n\nWith `GeoPandas`, when you use the `plot` method with `legend=True` the type of legend that appears depends on the data being visualized:\n\n- Continuous Data: For columns with continuous data (like population estimates, temperatures, etc.), a colour bar is generated as the legend. This color bar represents a range of values with a gradient, indicating how data values correspond to colours on the map.\n- Categorical Data: For columns with categorical data (like country names, types of land use, etc.), if you specify `legend=True`, `GeoPandas` will try to create a legend that categorizes these distinct values with different colours. However, creating legends for categorical data is not as straightforward as with continuous data and might require additional handling for a clear and informative legend (see below).\n\n#### Scheme\nIt is important to keep in mind that choropleth maps strongly depend on the scheme that it is passed (or the default one) to classify the data in groups. The plot above only shows one municipality coloured in dark blue.\n\nLook at the following plots and how three different classifiers produce different results for the same data.\n\nRefer to https://geopandas.org/en/stable/gallery/choropleths.html \nand https://geographicdata.science/book/notebooks/05_choropleth.html for further details\n\n- The *Equal intervals* method splits the range of the distribution, the difference between the minimum and maximum value, into equally large segments and to assign a different colour to each of them according to a palette that reflects the fact that values are ordered.\n- To obtain a more balanced classification, one can use the *Quantiles* scheme. This assigns the same amount of values to each bin: the entire series is laid out in order and break points are assigned in a way that leaves exactly the same amount of observations between each of them. This \"observation-based\" approach contrasts with the \"value-based\" method of equal intervals and, although it can obscure the magnitude of extreme values, it can be more informative in cases with skewed distributions.\n- Amongst many other, the *Fisher Jenks* dynamically minimises the sum of the absolute deviations around class medians. The Fisher-Jenks algorithm is guaranteed to produce an optimal classification for a prespecified number of classes.\n\nThe only additional arguments to pass for producing a choropleth, therefore, are the actual variable we would like to classify and the number of segments we want to create, `k`. This is, in other words, the number of colours that will be plotted on the map so, although having several can give more detail, at some point the marginal value of an additional one is fairly limited, given the ability of the human brain to tell any differences.\n\nAlso consider the [Modifiable Areal Unit Problem](https://en.wikipedia.org/wiki/Modifiable_areal_unit_problem) and how the geographies of the administrative boundaries, in this case, may impact the visualisation.\n\n<img src=\"../labs_img/MAUP.jpg/\" width = \"70%\">\n\nFor example, the most populated area is a municipality in the north that corresponds to the city of Novi Sad. \nLet's have a look at the data\n\nIn our dataset, the city of Novi Sad is categorised as a municipality by itself, because the administrative boundaries file is not updated. In reality, \"since 2002, when the new statute of the city of Novi Sad came into effect, Novi Sad is divided into two city municipalities, Petrovaradin and Novi Sad. From 1989 until 2002, the name Municipality of Novi Sad meant the whole territory of the present-day city of Novi Sad.\" (see: [wikipedia](https://en.wikipedia.org/wiki/City_municipality_of_Novi_Sad)).  \n\nOn the contrary, Grad Beograd, that is Belgrade, is correctly split into different municipalities and its population, when visualised, is spread out across the different geometries of its municipalities. In other words, our map depends on the geometries of the areas and on how the data was collected. While it could be that these areas were indeed identified by population size in the first place, the point is that the fact that Novi Sad is not split into more areas, as Belgrade is, makes it stound out more clearly from the map (and to some extent a bit unfairly)\n\nThis may happen with different types of data, particularly with administrative boundaries and it is crucial to reflect on how Choropleth maps may be impacted. One can look for more granular data or consider to weight the continuous value with the extent of the area (i.e. obtaining density values).\n\n#### An alternative to scheme: ColorMap Normalisation\n\nThe `mpl.colors.Normalize` function in `matplotlib` creates a normalization object, which adjusts data values into a range that is ideal for colour mapping in a colormap. This function is particularly beneficial in scenarios where precise control over the mapping of data values to colour representations is needed.\n\nWhen employed in a plotting function, this normalization object ensures that the data values are scaled to fit a pre-defined range (for instance, `norm = mpl.colors.Normalize(vmin=0, vmax=40)`). Any values falling below 0 are mapped to the lowest colour on the colormap scale, while values exceeding 40 are mapped to the highest colour. This approach is especially useful when aiming to highlight differences within a specific data range; it can significantly enhance the visualization of data, by, for example, emphasizing temperature variations between 0°C and 40°C. This becomes crucial in instances where a few data points with high values (e.g., 50°C) might otherwise lead to a less informative visualization if not 'normalized' and treated as if they corresponded to 40° C values.\n\nFor our dataset, we can use as `vmax` the value corresponding to the 90th percentile.\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\nWhen passing `norm` in the `plot` method, do not pass the arguments to the `scheme` parameter. For continuous variables, `norm` maps each value directly to a color, making discrete categorization redundant. In other words, it allows for a direct mapping of data values to the color map, eliminating the need for intermediary classification schemes. `norm` ensures a smooth gradient in the color map without artificially segmenting the data.\n</div>\n\n#### Customising the colorbar\n\nAbove, we removed the outline of the color bar. Then we set the tick values to the min and the max population values, based on our norm object. Then, for the vmax value's label we added a \">=\" to remind us that other, higher values are displayed with the darkest color.\n\n#### Varying alpha transparency based on an array\nFinally, we can also convey variation in a continuous scale through transparency. `alpha` doesn't expect column names, so we cannot just pass the name of the column containing the variable. Instead, we have to create an array from 0.0 to 1.0 values. To so we can a) use normalisation methods, or b) rescale the original values within 0 to 1 based on the original min and max values.\n\nFor example, with square root normalization:\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\n`matplotlib` would not able to plot a color bar from variations in the alpha value since no column is passed directly. We would need, in this case, to build a color bar manually as demonstrated above.\n</div>\n\n### Choropleth Maps for Categorical Variables\nA choropleth for categorical variables assigns a different color to every potential value in the series based on certain colormaps (`cmap`).\nWe don't need to specify a scheme in this case, but just to the categorical `column`. Using last's week GeoDataFrame, we can plot terrorist attacks in Germany, for example, by group.\n\nThe map above is what you would get from datasets that are not cleaned/manipulated directly or when there are too many categories in the selected column. First, let's get a slimmer slice of the gdf that only contains attacks that cause a number of fatalities and wounded higher than 10.\n\nThen, let's build a function that creates a random color map based on the number of categories. This creates random `HUE`-based colors:\n\nWe also place the legend on the centre left. This is done automatically, but the legend and its items can be manipulated directly.\nLegends in `matplotlib` are extremely complex to personalise. However, do have a look at https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html#matplotlib.pyplot.legend for both automatic and explicit manipulation.\n\nWe can also convey the impact of the events through the `markersize`. This introduces the concept of *cartogram* (see below).\n\n## Part III: Cartograms - Manipulating the Geometry size for showing the magnitude of a value \n\n[Cartograms](https://www.data-to-viz.com/graph/cartogram.html) are maps that represent the spatial distribution of a variable not by encoding it in a color palette but rather by modifying geographical objects. There are many algorithms to distort the shapes of geographical entities according to values, some of them are rather complex. \n\n### Polygons\nYou can obtain cartograms for `Polygon` with `geoplot`: see https://residentmario.github.io/geoplot/\n\n`geoplot` functions pretty much work as `plot`\n\n### Points\nFor `Point` GeoDataFrames we can just go back to `plot` and pass a column name to `markersize`.\n\nOne can also convert polygons into points by using their centroids, and then define the size of the dot proportionally to the value of the variable we want to display.\n\n### LineString\nFor `LineString` we pass the column name to `linewidth`.  \n\nLet's load a shapefile of lines. These lines represent frequency of train connections from/to train stations in the region of Liguria (Italy) to other stations within or outside the region. Each line refers to a connection between two specific stations, through a certain type of service and contains information about the frequency of that type of service. For example, the cities of Savona and Finale Ligure might be connected by 5 InterCity trains and 50 regional services. These services correspond to 2 different records.\n\nLet's check the type of services contained here. \n\nWe have:\n- 'REG': regional trains.\n- 'IC': intercity trains.\n- 'FB': similar to IC, but slightly faster.\n- 'ICN':  sleeper trains.\n- 'U': urban trains (Genoa).\n- 'EC/EN': international trains.\n- 'AV': High-speed trains.\n\nLet's keep just regional, intercity, and high-speed trains.\n\nThe usage of `linewdith` is a bit different from `markersize` for some reason. We have to pass an `array` of N values, where N is equal to the GeoDataFrame size. In other words, we have to pass the column we want to use to regulate the line width directly as a list/array. Specifying the column name is not enough.\n\nAs you can see, the default arguments and simply passing the column values do not produce pretty results. \nThe first thing to look at is the values that are passed to `linewidth`.  In some cases, the min and max values, as well as their distribution, are not ideal for visually conveying the magnitude of the variable attached to the geometry. One option is to use a multiplier factor (see below), or to rescale the values from 0 to 1, for example, and then, again, if necessary use a multiplier.\n\nWhile this looks a bit better, this visualisation is not ideal because the frequencies are not snapped to the actual railway network. The lines represent, instead, connection between train stops and therefore their coordinates only include the ones corresponding to the stations where the different services call at. One can devise approaches to:\n\n- Assigning the frequencies, or any other value, to the corresponding infrastructure's section. For example, the railway section between two stations could be associated with a value representing the total number of regional/local services travelling along it.\n- Smoothing the lines representing the services by adding further coordinates along the line.\n\nBoth these processes go beyond the scopes of this lab and require several considerations depending on the data, the scale, and what information one wants to displays.\n\n<div class=\"alert alert-success\">\n\n**Exercise**:\n\nToday we've seen how to exploit `matplotlib` to plot `GeoDataFrame` layers. Go through the notebook again if you feel that there's something you need to review. You are not expected to remember each step/method/parameter. Rather, this notebook should be used as a reference for producing maps in Python. Do keep in mind that most of the maps above have been produced with just a bunch of rows, so each of them can be improved and embellished with some more effort.\n\nNow, if you are not overwhelmed, have a look at the very last map and produce some nice visualisation using the same data. You can further improve its clarity, add a legend that refers to the line width, visualise only a certain type of services, or add information/context, for example. In the folder `\\data` you can also find a `.shp` file containing all the train stations in Italy, should you need that.\n\n</div>\n\n#### Saving figures (check [here for details](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html))\n","srcMarkdownNoYaml":"\n\nThe **Lecture slides** can be found [here](https://github.com/GDSL-UL/wma/blob/main/lectures/w02.pdf).\n\nThis **lab**'s notebook can be downloaded from [here](https://github.com/GDSL-UL/wma/blob/main/labs/w02_maps.ipynb).\n\n## Part I: Basic Maps\n\nIn this session, we will use the libraries `matplotlib` and `contextily` to plot the information represented into different `GeoDataFrames`. \nWe will look into plotting `Point`, `LineString` and `Polygon` `GeoDataFrames`. Most of the plots here are rather ugly but, at this point, the goal is to get familiar with the parameters of the plot function and what can be done with them.\n\n### Plotting Points\n\nLoad the data of terrorist attacks 1970-2020 and choose a country. Germany is used as a case study here but feel free to change the country.\nIf you do so, also change the `crs` (see https://epsg.io).\n\nCreating the `GeoDataFrame` from the `DataFrame`\n\nBasic plotting\n\nSlightly improving the plot:\n\n#### Adding some context: Base Maps with `Contextily`\nsee providers and options here https://xyzservices.readthedocs.io/en/stable/introduction.html\n\n#### Parameters specific to `Point` in the `plot` method \n- `markersize`: numerical value (for now)\n- `marker`: see https://matplotlib.org/stable/api/markers_api.html\n\n##### Other properties, shape independent:\n- `color`: https://matplotlib.org/3.1.0/gallery/color/named_colors.html\n- `alpha`: regulates transparency of the shape: 0 to 1\n\n### Plotting LineStrings\nLet's import railway tracks in the Western Balkans (Slovenia, Croatia, Bosnia & Herzegovina, Montenegro, Serbia, Kosovo)\n\nOne can also filter prior to plotting, based on the columns in the GeoDataFrame. First we download Serbia's Boundary with `OSMNX`, more on that later on. Then we filter `lines_gdf` with a `within` operation.\n\n#### Parameters specific to `LineString`: \n- `linewidth`: numerical value (for now).\n- `capstyle`: controls how Matplotlib draws the corners where two different line segments meet. See https://matplotlib.org/stable/gallery/lines_bars_and_markers/capstyle.html\n- `joinstyle`': controls how Matplotlib draws the corners where two different line segments meet. https://matplotlib.org/stable/gallery/lines_bars_and_markers/joinstyle.html\n\n### Plotting Polygons\nWe are again using `OSMNX` to download data from `OpenStreetMap` automatically. In this case, we will get building footprints from the city of Algiers in Alageria.\n\n#### Parameter specific to `Polygon`: \n- `edgecolor`: the outline of the polygon, by default = `None` (often better).\n- `linewidth`: the width of the outline of the polygon.\n\nFor polygons, you can also plot just the boundaries of the geometries by:\n\n### Plotting more than one layer together\nLet's also download roads for Algiers\n\nAnd plot everything togehter. It's important to keep in mind that the last layer is always rendered on top of the others. In other words, they may cover the previous ones.\n\nHowever, you can prevent this by passing arguments to the parameter `zorder` in the `plot` method. The layer with the higher zorder value will be plotted on top. \n\n### Sub-plots\nTo obtain multiple sub-plots, we manipulate the `nrows`, `ncols` parameters. We can use this approach to:\n* Plot the same layer with different properties.\n\n* Plot different layers.\n\n* Analyse phenomena across different geographical areas. For example, terrorism in Germany and in the UK.\n\n<div class=\"alert alert-success\">\n\n**Exercise**:\n\n* Think about the plots above and how they could be improved. \n* Copy and paste the code and execute the functions playing with the different parameters.\n* Produce a neat map using the `GeoDataFrame`s available in this notebook or the ones employed in the previous sessions, making use of the elements/parameters discussed here.\n* Try out different tiles for the basemap to familiarise yourself with what's available.\n    \n</div>\n\n## Part II: Choropleth Mapping\n\n**Data**\n\nFor this second part of the tutorial, we will use some data at the municipality level for Serbia. The data contains information regarding poverty level, average income, population and tourism. The data is taken from https://data.stat.gov.rs/?caller=SDDB&languageCode=en-US and can be associated to the polygons representing the administrative boundaries of the municipalities. These boundaries can be found here https://data.humdata.org/dataset/geoboundaries-admin-boundaries-for-serbia?force_layout=desktop.\nWhile most of the data refers to 2023, the admin boundaries file traces back to 2017. Thus, it may contain obsolete information (few changes may occur).\n\nLater on, we will go back to the terrorism dataset.\n\nLet's plot the `GeoDataFrame` following the last session's steps.\n\nThe we load the data and merge it into the `GeoDataFrame`, before getting rid of municipalities that do not have a corresponding shape/record in the GeoDataFrame (probably the result of changes in the national subdivisions).\n\nCreating a choropleth map is rather straightforward and can ben done by using few other parameters. Reflect on what you see and whether the map below is informative.\n\n### Choropleth Maps for Numerical Variables\nWe are essentially  using the same approach employed for creating basic maps, the method `plot`, but we now need to pass arguments to some new parameters to specify which column is to be represented and how. As an optional argument, one can set legend to `True` and the resulting figure will include a colour bar.\n\n- `column`: the name of the column representing the variable that we want to use to colour-code our shapes.\n- `scheme`: the scheme used to colour the shapes based on the variable values.\n- `cmap`: the colormap used to show variation.\n\n#### Colormaps\n\nBuilt-in colour maps can be found here https://matplotlib.org/stable/gallery/color/colormap_reference.html.\nHowever one can create new ones as follows from a list of colours:\n\nor from colour names: \n\nLet's try a new colormap and let's also set a number of classes to divide the data in, through the parameter `k`.\n\nWith `GeoPandas`, when you use the `plot` method with `legend=True` the type of legend that appears depends on the data being visualized:\n\n- Continuous Data: For columns with continuous data (like population estimates, temperatures, etc.), a colour bar is generated as the legend. This color bar represents a range of values with a gradient, indicating how data values correspond to colours on the map.\n- Categorical Data: For columns with categorical data (like country names, types of land use, etc.), if you specify `legend=True`, `GeoPandas` will try to create a legend that categorizes these distinct values with different colours. However, creating legends for categorical data is not as straightforward as with continuous data and might require additional handling for a clear and informative legend (see below).\n\n#### Scheme\nIt is important to keep in mind that choropleth maps strongly depend on the scheme that it is passed (or the default one) to classify the data in groups. The plot above only shows one municipality coloured in dark blue.\n\nLook at the following plots and how three different classifiers produce different results for the same data.\n\nRefer to https://geopandas.org/en/stable/gallery/choropleths.html \nand https://geographicdata.science/book/notebooks/05_choropleth.html for further details\n\n- The *Equal intervals* method splits the range of the distribution, the difference between the minimum and maximum value, into equally large segments and to assign a different colour to each of them according to a palette that reflects the fact that values are ordered.\n- To obtain a more balanced classification, one can use the *Quantiles* scheme. This assigns the same amount of values to each bin: the entire series is laid out in order and break points are assigned in a way that leaves exactly the same amount of observations between each of them. This \"observation-based\" approach contrasts with the \"value-based\" method of equal intervals and, although it can obscure the magnitude of extreme values, it can be more informative in cases with skewed distributions.\n- Amongst many other, the *Fisher Jenks* dynamically minimises the sum of the absolute deviations around class medians. The Fisher-Jenks algorithm is guaranteed to produce an optimal classification for a prespecified number of classes.\n\nThe only additional arguments to pass for producing a choropleth, therefore, are the actual variable we would like to classify and the number of segments we want to create, `k`. This is, in other words, the number of colours that will be plotted on the map so, although having several can give more detail, at some point the marginal value of an additional one is fairly limited, given the ability of the human brain to tell any differences.\n\nAlso consider the [Modifiable Areal Unit Problem](https://en.wikipedia.org/wiki/Modifiable_areal_unit_problem) and how the geographies of the administrative boundaries, in this case, may impact the visualisation.\n\n<img src=\"../labs_img/MAUP.jpg/\" width = \"70%\">\n\nFor example, the most populated area is a municipality in the north that corresponds to the city of Novi Sad. \nLet's have a look at the data\n\nIn our dataset, the city of Novi Sad is categorised as a municipality by itself, because the administrative boundaries file is not updated. In reality, \"since 2002, when the new statute of the city of Novi Sad came into effect, Novi Sad is divided into two city municipalities, Petrovaradin and Novi Sad. From 1989 until 2002, the name Municipality of Novi Sad meant the whole territory of the present-day city of Novi Sad.\" (see: [wikipedia](https://en.wikipedia.org/wiki/City_municipality_of_Novi_Sad)).  \n\nOn the contrary, Grad Beograd, that is Belgrade, is correctly split into different municipalities and its population, when visualised, is spread out across the different geometries of its municipalities. In other words, our map depends on the geometries of the areas and on how the data was collected. While it could be that these areas were indeed identified by population size in the first place, the point is that the fact that Novi Sad is not split into more areas, as Belgrade is, makes it stound out more clearly from the map (and to some extent a bit unfairly)\n\nThis may happen with different types of data, particularly with administrative boundaries and it is crucial to reflect on how Choropleth maps may be impacted. One can look for more granular data or consider to weight the continuous value with the extent of the area (i.e. obtaining density values).\n\n#### An alternative to scheme: ColorMap Normalisation\n\nThe `mpl.colors.Normalize` function in `matplotlib` creates a normalization object, which adjusts data values into a range that is ideal for colour mapping in a colormap. This function is particularly beneficial in scenarios where precise control over the mapping of data values to colour representations is needed.\n\nWhen employed in a plotting function, this normalization object ensures that the data values are scaled to fit a pre-defined range (for instance, `norm = mpl.colors.Normalize(vmin=0, vmax=40)`). Any values falling below 0 are mapped to the lowest colour on the colormap scale, while values exceeding 40 are mapped to the highest colour. This approach is especially useful when aiming to highlight differences within a specific data range; it can significantly enhance the visualization of data, by, for example, emphasizing temperature variations between 0°C and 40°C. This becomes crucial in instances where a few data points with high values (e.g., 50°C) might otherwise lead to a less informative visualization if not 'normalized' and treated as if they corresponded to 40° C values.\n\nFor our dataset, we can use as `vmax` the value corresponding to the 90th percentile.\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\nWhen passing `norm` in the `plot` method, do not pass the arguments to the `scheme` parameter. For continuous variables, `norm` maps each value directly to a color, making discrete categorization redundant. In other words, it allows for a direct mapping of data values to the color map, eliminating the need for intermediary classification schemes. `norm` ensures a smooth gradient in the color map without artificially segmenting the data.\n</div>\n\n#### Customising the colorbar\n\nAbove, we removed the outline of the color bar. Then we set the tick values to the min and the max population values, based on our norm object. Then, for the vmax value's label we added a \">=\" to remind us that other, higher values are displayed with the darkest color.\n\n#### Varying alpha transparency based on an array\nFinally, we can also convey variation in a continuous scale through transparency. `alpha` doesn't expect column names, so we cannot just pass the name of the column containing the variable. Instead, we have to create an array from 0.0 to 1.0 values. To so we can a) use normalisation methods, or b) rescale the original values within 0 to 1 based on the original min and max values.\n\nFor example, with square root normalization:\n\n<div class=\"alert alert-info\" style=\"font-size:120%\">\n\n**Important**: <br>\n\n`matplotlib` would not able to plot a color bar from variations in the alpha value since no column is passed directly. We would need, in this case, to build a color bar manually as demonstrated above.\n</div>\n\n### Choropleth Maps for Categorical Variables\nA choropleth for categorical variables assigns a different color to every potential value in the series based on certain colormaps (`cmap`).\nWe don't need to specify a scheme in this case, but just to the categorical `column`. Using last's week GeoDataFrame, we can plot terrorist attacks in Germany, for example, by group.\n\nThe map above is what you would get from datasets that are not cleaned/manipulated directly or when there are too many categories in the selected column. First, let's get a slimmer slice of the gdf that only contains attacks that cause a number of fatalities and wounded higher than 10.\n\nThen, let's build a function that creates a random color map based on the number of categories. This creates random `HUE`-based colors:\n\nWe also place the legend on the centre left. This is done automatically, but the legend and its items can be manipulated directly.\nLegends in `matplotlib` are extremely complex to personalise. However, do have a look at https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html#matplotlib.pyplot.legend for both automatic and explicit manipulation.\n\nWe can also convey the impact of the events through the `markersize`. This introduces the concept of *cartogram* (see below).\n\n## Part III: Cartograms - Manipulating the Geometry size for showing the magnitude of a value \n\n[Cartograms](https://www.data-to-viz.com/graph/cartogram.html) are maps that represent the spatial distribution of a variable not by encoding it in a color palette but rather by modifying geographical objects. There are many algorithms to distort the shapes of geographical entities according to values, some of them are rather complex. \n\n### Polygons\nYou can obtain cartograms for `Polygon` with `geoplot`: see https://residentmario.github.io/geoplot/\n\n`geoplot` functions pretty much work as `plot`\n\n### Points\nFor `Point` GeoDataFrames we can just go back to `plot` and pass a column name to `markersize`.\n\nOne can also convert polygons into points by using their centroids, and then define the size of the dot proportionally to the value of the variable we want to display.\n\n### LineString\nFor `LineString` we pass the column name to `linewidth`.  \n\nLet's load a shapefile of lines. These lines represent frequency of train connections from/to train stations in the region of Liguria (Italy) to other stations within or outside the region. Each line refers to a connection between two specific stations, through a certain type of service and contains information about the frequency of that type of service. For example, the cities of Savona and Finale Ligure might be connected by 5 InterCity trains and 50 regional services. These services correspond to 2 different records.\n\nLet's check the type of services contained here. \n\nWe have:\n- 'REG': regional trains.\n- 'IC': intercity trains.\n- 'FB': similar to IC, but slightly faster.\n- 'ICN':  sleeper trains.\n- 'U': urban trains (Genoa).\n- 'EC/EN': international trains.\n- 'AV': High-speed trains.\n\nLet's keep just regional, intercity, and high-speed trains.\n\nThe usage of `linewdith` is a bit different from `markersize` for some reason. We have to pass an `array` of N values, where N is equal to the GeoDataFrame size. In other words, we have to pass the column we want to use to regulate the line width directly as a list/array. Specifying the column name is not enough.\n\nAs you can see, the default arguments and simply passing the column values do not produce pretty results. \nThe first thing to look at is the values that are passed to `linewidth`.  In some cases, the min and max values, as well as their distribution, are not ideal for visually conveying the magnitude of the variable attached to the geometry. One option is to use a multiplier factor (see below), or to rescale the values from 0 to 1, for example, and then, again, if necessary use a multiplier.\n\nWhile this looks a bit better, this visualisation is not ideal because the frequencies are not snapped to the actual railway network. The lines represent, instead, connection between train stops and therefore their coordinates only include the ones corresponding to the stations where the different services call at. One can devise approaches to:\n\n- Assigning the frequencies, or any other value, to the corresponding infrastructure's section. For example, the railway section between two stations could be associated with a value representing the total number of regional/local services travelling along it.\n- Smoothing the lines representing the services by adding further coordinates along the line.\n\nBoth these processes go beyond the scopes of this lab and require several considerations depending on the data, the scale, and what information one wants to displays.\n\n<div class=\"alert alert-success\">\n\n**Exercise**:\n\nToday we've seen how to exploit `matplotlib` to plot `GeoDataFrame` layers. Go through the notebook again if you feel that there's something you need to review. You are not expected to remember each step/method/parameter. Rather, this notebook should be used as a reference for producing maps in Python. Do keep in mind that most of the maps above have been produced with just a bunch of rows, so each of them can be improved and embellished with some more effort.\n\nNow, if you are not overwhelmed, have a look at the very last map and produce some nice visualisation using the same data. You can further improve its clarity, add a legend that refers to the line width, visualise only a certain type of services, or add information/context, for example. In the folder `\\data` you can also find a `.shp` file containing all the train stations in Italy, should you need that.\n\n</div>\n\n#### Saving figures (check [here for details](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.savefig.html))\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"output-file":"w02_maps.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.546","bibliography":["../references.bib"],"editor":"visual","theme":"zephyr","title":"Static Maps in Python","author":"Gabriele Filomena","date":"today"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"w02_maps.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"block-headings":true,"bibliography":["../references.bib"],"editor":"visual","documentclass":"scrreprt","title":"Static Maps in Python","author":"Gabriele Filomena","date":"today"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}